# Object-Oriented Programming Features Demo
# نشان‌دهندهٔ ویژگی‌های برنامه‌نویسی شیءگرا در Plix

# --- ۱. کلاس‌های پایه و ارث‌بری ---
class Animal {
    name: string;
    age: number;
    
    def __init__(name: string, age: number) {
        self.name = name;
        self.age = age;
    }
    
    def speak() -> string {
        return "Some generic animal sound";
    }
    
    def get_info() -> string {
        return self.name + " is " + self.age + " years old";
    }
    
    def is_adult() -> boolean {
        return self.age >= 1;
    }
}

class Dog extends Animal {
    breed: string;
    loyalty_level: number;
    
    def __init__(name: string, age: number, breed: string, loyalty_level: number = 10) {
        super.__init__(name, age);
        self.breed = breed;
        self.loyalty_level = loyalty_level;
    }
    
    def speak() -> string {
        return "Woof! Woof!";
    }
    
    def wag_tail() -> string {
        return self.name + " is wagging its tail happily!";
    }
    
    def fetch(item: string) -> string {
        return self.name + " fetched the " + item;
    }
    
    def get_breed_info() -> string {
        return self.name + " is a " + self.breed + " with loyalty level " + self.loyalty_level;
    }
}

class Cat extends Animal {
    color: string;
    independence_level: number;
    
    def __init__(name: string, age: number, color: string, independence_level: number = 5) {
        super.__init__(name, age);
        self.color = color;
        self.independence_level = independence_level;
    }
    
    def speak() -> string {
        return "Meow!";
    }
    
    def purr() -> string {
        return self.name + " is purring contentedly";
    }
    
    def climb() -> string {
        return self.name + " climbed to a high place";
    }
    
    def get_color_info() -> string {
        return self.name + " is a " + self.color + " cat with independence level " + self.independence_level;
    }
}

# --- ۲. کلاس‌های انتزاعی و رابط‌ها ---
interface Drawable {
    def draw() -> void;
    def get_area() -> number;
    def get_perimeter() -> number;
}

interface Movable {
    def move(x: number, y: number) -> void;
    def get_position() -> (number, number);
}

interface Serializable {
    def to_string() -> string;
    def from_string(data: string) -> Self;
}

# --- ۳. کلاس‌های پیاده‌سازی رابط‌ها ---
class Point implements Movable, Serializable {
    x: number;
    y: number;
    
    def __init__(x: number, y: number) {
        self.x = x;
        self.y = y;
    }
    
    def move(new_x: number, new_y: number) {
        self.x = new_x;
        self.y = new_y;
    }
    
    def get_position() -> (number, number) {
        return (self.x, self.y);
    }
    
    def to_string() -> string {
        return "Point(" + self.x + ", " + self.y + ")";
    }
    
    def from_string(data: string) -> Point {
        # Simple parsing for demonstration
        mut parts = data.replace("Point(", "").replace(")", "").split(",");
        return Point(parts[0].trim().to_number(), parts[1].trim().to_number());
    }
}

class Circle extends Point implements Drawable {
    radius: number;
    
    def __init__(x: number, y: number, radius: number) {
        super.__init__(x, y);
        self.radius = radius;
    }
    
    def draw() {
        print("Drawing a circle at " + self.to_string() + " with radius " + self.radius);
    }
    
    def get_area() -> number {
        return 3.14159 * self.radius * self.radius;
    }
    
    def get_perimeter() -> number {
        return 2 * 3.14159 * self.radius;
    }
    
    def resize(new_radius: number) {
        self.radius = new_radius;
    }
}

class Rectangle implements Drawable, Movable, Serializable {
    x: number;
    y: number;
    width: number;
    height: number;
    
    def __init__(x: number, y: number, width: number, height: number) {
        self.x = x;
        self.y = y;
        self.width = width;
        self.height = height;
    }
    
    def draw() {
        print("Drawing a rectangle at (" + self.x + ", " + self.y + ") with size " + self.width + "x" + self.height);
    }
    
    def get_area() -> number {
        return self.width * self.height;
    }
    
    def get_perimeter() -> number {
        return 2 * (self.width + self.height);
    }
    
    def move(new_x: number, new_y: number) {
        self.x = new_x;
        self.y = new_y;
    }
    
    def get_position() -> (number, number) {
        return (self.x, self.y);
    }
    
    def to_string() -> string {
        return "Rectangle(" + self.x + ", " + self.y + ", " + self.width + ", " + self.height + ")";
    }
    
    def from_string(data: string) -> Rectangle {
        # Simple parsing for demonstration
        mut parts = data.replace("Rectangle(", "").replace(")", "").split(",");
        return Rectangle(
            parts[0].trim().to_number(),
            parts[1].trim().to_number(),
            parts[2].trim().to_number(),
            parts[3].trim().to_number()
        );
    }
    
    def resize(new_width: number, new_height: number) {
        self.width = new_width;
        self.height = new_height;
    }
}

# --- ۴. کلاس‌های تو در تو (Nested Classes) ---
class University {
    name: string;
    students: Array<Student>;
    professors: Array<Professor>;
    
    class Student {
        student_id: string;
        name: string;
        major: string;
        year: number;
        
        def __init__(student_id: string, name: string, major: string, year: number) {
            self.student_id = student_id;
            self.name = name;
            self.major = major;
            self.year = year;
        }
        
        def get_info() -> string {
            return "Student: " + self.name + " (ID: " + self.student_id + ") - " + self.major + ", Year " + self.year;
        }
        
        def enroll_in_course(course: Course) -> string {
            return self.name + " enrolled in " + course.name;
        }
    }
    
    class Professor {
        professor_id: string;
        name: string;
        department: string;
        courses: Array<Course>;
        
        def __init__(professor_id: string, name: string, department: string) {
            self.professor_id = professor_id;
            self.name = name;
            self.department = department;
            self.courses = [];
        }
        
        def get_info() -> string {
            return "Professor: " + self.name + " (ID: " + self.professor_id + ") - " + self.department;
        }
        
        def teach_course(course: Course) -> string {
            self.courses.push(course);
            return self.name + " is now teaching " + course.name;
        }
    }
    
    class Course {
        course_id: string;
        name: string;
        credits: number;
        professor: Professor | null;
        
        def __init__(course_id: string, name: string, credits: number) {
            self.course_id = course_id;
            self.name = name;
            self.credits = credits;
            self.professor = null;
        }
        
        def assign_professor(prof: Professor) {
            self.professor = prof;
        }
        
        def get_info() -> string {
            mut prof_info: string = "No professor assigned";
            if (self.professor != null) {
                prof_info = "Professor: " + self.professor.name;
            }
            return "Course: " + self.name + " (ID: " + self.course_id + ", Credits: " + self.credits + ") - " + prof_info;
        }
    }
    
    def __init__(name: string) {
        self.name = name;
        self.students = [];
        self.professors = [];
    }
    
    def add_student(student: Student) {
        self.students.push(student);
    }
    
    def add_professor(professor: Professor) {
        self.professors.push(professor);
    }
    
    def get_student_count() -> number {
        return self.students.length;
    }
    
    def get_professor_count() -> number {
        return self.professors.length;
    }
    
    def get_info() -> string {
        return self.name + " has " + self.students.length + " students and " + self.professors.length + " professors";
    }
}

# --- ۵. کلاس‌های عمومی (Generic Classes) ---
class Container<T> {
    items: Array<T>;
    
    def __init__() {
        self.items = [];
    }
    
    def add(item: T) {
        self.items.push(item);
    }
    
    def get(index: number) -> T | null {
        if (index >= 0 && index < self.items.length) {
            return self.items[index];
        }
        return null;
    }
    
    def remove(item: T) -> boolean {
        mut index: number = self.items.index_of(item);
        if (index != -1) {
            self.items.splice(index, 1);
            return true;
        }
        return false;
    }
    
    def size() -> number {
        return self.items.length;
    }
    
    def is_empty() -> boolean {
        return self.items.length == 0;
    }
    
    def clear() {
        self.items = [];
    }
    
    def to_array() -> Array<T> {
        return self.items.copy();
    }
}

class Stack<T> extends Container<T> {
    def push(item: T) {
        self.add(item);
    }
    
    def pop() -> T | null {
        if (self.is_empty()) {
            return null;
        }
        return self.items.pop();
    }
    
    def peek() -> T | null {
        if (self.is_empty()) {
            return null;
        }
        return self.items[self.items.length - 1];
    }
}

class Queue<T> extends Container<T> {
    def enqueue(item: T) {
        self.add(item);
    }
    
    def dequeue() -> T | null {
        if (self.is_empty()) {
            return null;
        }
        return self.items.shift();
    }
    
    def front() -> T | null {
        if (self.is_empty()) {
            return null;
        }
        return self.items[0];
    }
}

class BinaryTree<T> {
    value: T;
    left: BinaryTree<T> | null;
    right: BinaryTree<T> | null;
    
    def __init__(value: T) {
        self.value = value;
        self.left = null;
        self.right = null;
    }
    
    def insert(value: T) {
        if (value < self.value) {
            if (self.left == null) {
                self.left = BinaryTree(value);
            } else {
                self.left.insert(value);
            }
        } else {
            if (self.right == null) {
                self.right = BinaryTree(value);
            } else {
                self.right.insert(value);
            }
        }
    }
    
    def search(value: T) -> boolean {
        if (value == self.value) {
            return true;
        } else if (value < self.value) {
            if (self.left == null) {
                return false;
            }
            return self.left.search(value);
        } else {
            if (self.right == null) {
                return false;
            }
            return self.right.search(value);
        }
    }
    
    def inorder_traversal() -> Array<T> {
        mut result: Array<T> = [];
        
        if (self.left != null) {
            result = result + self.left.inorder_traversal();
        }
        
        result.push(self.value);
        
        if (self.right != null) {
            result = result + self.right.inorder_traversal();
        }
        
        return result;
    }
    
    def preorder_traversal() -> Array<T> {
        mut result: Array<T> = [self.value];
        
        if (self.left != null) {
            result = result + self.left.preorder_traversal();
        }
        
        if (self.right != null) {
            result = result + self.right.preorder_traversal();
        }
        
        return result;
    }
    
    def postorder_traversal() -> Array<T> {
        mut result: Array<T> = [];
        
        if (self.left != null) {
            result = result + self.left.postorder_traversal();
        }
        
        if (self.right != null) {
            result = result + self.right.postorder_traversal();
        }
        
        result.push(self.value);
        
        return result;
    }
}

# --- ۶. کلاس‌های استاتیک و متدهای کلاس ---
class MathUtils {
    const PI: number = 3.14159;
    const E: number = 2.71828;
    
    def static factorial(n: number) -> number {
        if (n <= 1) {
            return 1;
        }
        return n * MathUtils.factorial(n - 1);
    }
    
    def static fibonacci(n: number) -> number {
        if (n <= 1) {
            return n;
        }
        return MathUtils.fibonacci(n - 1) + MathUtils.fibonacci(n - 2);
    }
    
    def static gcd(a: number, b: number) -> number {
        while (b != 0) {
            mut temp: number = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
    
    def static lcm(a: number, b: number) -> number {
        return (a * b) / MathUtils.gcd(a, b);
    }
    
    def static is_prime(n: number) -> boolean {
        if (n <= 1) {
            return false;
        }
        for (i in range(2, n ** 0.5 + 1)) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
    
    def static distance(x1: number, y1: number, x2: number, y2: number) -> number {
        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5;
    }
    
    def static clamp(value: number, min_val: number, max_val: number) -> number {
        if (value < min_val) {
            return min_val;
        } else if (value > max_val) {
            return max_val;
        }
        return value;
    }
}

class StringUtils {
    def static reverse(str: string) -> string {
        mut result: string = "";
        for (i in range(str.length - 1, -1, -1)) {
            result = result + str[i];
        }
        return result;
    }
    
    def static capitalize(str: string) -> string {
        if (str.length == 0) {
            return str;
        }
        return str[0].to_uppercase() + str.substring(1).to_lowercase();
    }
    
    def static camel_case(str: string) -> string {
        mut words = str.split(" ");
        mut result: string = "";
        for (i in range(words.length)) {
            if (i == 0) {
                result = result + words[i].to_lowercase();
            } else {
                result = result + StringUtils.capitalize(words[i]);
            }
        }
        return result;
    }
    
    def static snake_case(str: string) -> string {
        mut result: string = "";
        for (char in str) {
            if (char.is_uppercase()) {
                if (result.length > 0) {
                    result = result + "_";
                }
                result = result + char.to_lowercase();
            } else {
                result = result + char;
            }
        }
        return result;
    }
    
    def static count_words(str: string) -> number {
        mut words = str.trim().split(" ");
        mut count: number = 0;
        for (word in words) {
            if (word.length > 0) {
                count = count + 1;
            }
        }
        return count;
    }
    
    def static is_palindrome(str: string) -> boolean {
        mut cleaned: string = str.replace(" ", "").replace(",", "").replace(".", "").to_lowercase();
        return cleaned == StringUtils.reverse(cleaned);
    }
}

# --- ۷. کلاس‌های با متد‌های اندیس‌گذاری ---
class Matrix<T> {
    data: Array<Array<T>>;
    rows: number;
    cols: number;
    
    def __init__(rows: number, cols: number, default_value: T) {
        self.rows = rows;
        self.cols = cols;
        self.data = [];
        
        for (i in range(rows)) {
            mut row: Array<T> = [];
            for (j in range(cols)) {
                row.push(default_value);
            }
            self.data.push(row);
        }
    }
    
    def get(row: number, col: number) -> T | null {
        if (row >= 0 && row < self.rows && col >= 0 && col < self.cols) {
            return self.data[row][col];
        }
        return null;
    }
    
    def set(row: number, col: number, value: T) {
        if (row >= 0 && row < self.rows && col >= 0 && col < self.cols) {
            self.data[row][col] = value;
        }
    }
    
    def get_row(row: number) -> Array<T> | null {
        if (row >= 0 && row < self.rows) {
            return self.data[row].copy();
        }
        return null;
    }
    
    def get_col(col: number) -> Array<T> | null {
        if (col >= 0 && col < self.cols) {
            mut result: Array<T> = [];
            for (row in range(self.rows)) {
                result.push(self.data[row][col]);
            }
            return result;
        }
        return null;
    }
    
    def transpose() -> Matrix<T> {
        mut result = Matrix(self.cols, self.rows, self.data[0][0]);
        for (i in range(self.rows)) {
            for (j in range(self.cols)) {
                result.set(j, i, self.get(i, j));
            }
        }
        return result;
    }
    
    def multiply(other: Matrix<T>) -> Matrix<T> {
        if (self.cols != other.rows) {
            throw "Matrix dimensions don't match for multiplication";
        }
        
        mut result = Matrix(self.rows, other.cols, 0 as T);
        
        for (i in range(self.rows)) {
            for (j in range(other.cols)) {
                mut sum: T = 0 as T;
                for (k in range(self.cols)) {
                    sum = sum + (self.get(i, k) as any) * (other.get(k, j) as any);
                }
                result.set(i, j, sum);
            }
        }
        
        return result;
    }
    
    def to_string() -> string {
        mut result: string = "";
        for (i in range(self.rows)) {
            for (j in range(self.cols)) {
                result = result + self.get(i, j) + "\t";
            }
            result = result + "\n";
        }
        return result;
    }
}

# --- ۸. کلاس‌های با متد‌های اپراتور ---
class ComplexNumber {
    real: number;
    imaginary: number;
    
    def __init__(real: number, imaginary: number) {
        self.real = real;
        self.imaginary = imaginary;
    }
    
    def add(other: ComplexNumber) -> ComplexNumber {
        return ComplexNumber(self.real + other.real, self.imaginary + other.imaginary);
    }
    
    def subtract(other: ComplexNumber) -> ComplexNumber {
        return ComplexNumber(self.real - other.real, self.imaginary - other.imaginary);
    }
    
    def multiply(other: ComplexNumber) -> ComplexNumber {
        mut real_part: number = self.real * other.real - self.imaginary * other.imaginary;
        mut imaginary_part: number = self.real * other.imaginary + self.imaginary * other.real;
        return ComplexNumber(real_part, imaginary_part);
    }
    
    def magnitude() -> number {
        return (self.real ** 2 + self.imaginary ** 2) ** 0.5;
    }
    
    def conjugate() -> ComplexNumber {
        return ComplexNumber(self.real, -self.imaginary);
    }
    
    def to_string() -> string {
        if (self.imaginary >= 0) {
            return self.real + " + " + self.imaginary + "i";
        } else {
            return self.real + " - " + (-self.imaginary) + "i";
        }
    }
}

# --- ۹. کلاس‌های با متد‌های ایونت ---
class EventEmitter {
    listeners: Object;
    
    def __init__() {
        self.listeners = {};
    }
    
    def on(event: string, callback: fn(any) -> void) {
        if (self.listeners[event] == null) {
            self.listeners[event] = [];
        }
        self.listeners[event].push(callback);
    }
    
    def emit(event: string, data: any) {
        if (self.listeners[event] != null) {
            for (callback in self.listeners[event]) {
                callback(data);
            }
        }
    }
    
    def off(event: string, callback: fn(any) -> void) {
        if (self.listeners[event] != null) {
            mut index: number = self.listeners[event].index_of(callback);
            if (index != -1) {
                self.listeners[event].splice(index, 1);
            }
        }
    }
    
    def once(event: string, callback: fn(any) -> void) {
        def wrapper(data: any) {
            callback(data);
            self.off(event, wrapper);
        }
        self.on(event, wrapper);
    }
}

# --- ۱۰. کلاس‌های با متد‌های ایستا و پویا ---
class Singleton {
    static instance: Singleton | null = null;
    
    def __init__() {
        if (Singleton.instance != null) {
            throw "Singleton can only be instantiated once";
        }
        Singleton.instance = self;
    }
    
    def static get_instance() -> Singleton {
        if (Singleton.instance == null) {
            Singleton.instance = Singleton();
        }
        return Singleton.instance;
    }
    
    def do_something() -> string {
        return "Singleton is doing something";
    }
}

class Factory {
    static create_animal(type: string, name: string, age: number) -> Animal {
        match type {
            case "dog" => {
                return Dog(name, age, "Unknown");
            }
            case "cat" => {
                return Cat(name, age, "Unknown");
            }
            default => {
                return Animal(name, age);
            }
        }
    }
    
    static create_shape(type: string, params: Object) -> Drawable {
        match type {
            case "circle" => {
                return Circle(params.x, params.y, params.radius);
            }
            case "rectangle" => {
                return Rectangle(params.x, params.y, params.width, params.height);
            }
            default => {
                throw "Unknown shape type";
            }
        }
    }
}

# --- ۱۱. کلاس‌های با متد‌های ایستا و پویا ---
def oop_demo() -> void {
    print("=== Object-Oriented Programming Demo ===");
    
    # Test inheritance
    print("\n1. Inheritance:");
    mut dog = Dog("Buddy", 3, "Golden Retriever");
    mut cat = Cat("Whiskers", 2, "Orange");
    
    print(dog.get_info());
    print(dog.speak());
    print(dog.wag_tail());
    print(dog.get_breed_info());
    
    print(cat.get_info());
    print(cat.speak());
    print(cat.purr());
    print(cat.get_color_info());
    
    # Test interfaces
    print("\n2. Interfaces:");
    mut circle = Circle(0, 0, 5);
    mut rect = Rectangle(1, 1, 4, 3);
    
    circle.draw();
    print("Circle area: ", circle.get_area());
    print("Circle perimeter: ", circle.get_perimeter());
    
    rect.draw();
    print("Rectangle area: ", rect.get_area());
    print("Rectangle perimeter: ", rect.get_perimeter());
    
    # Test nested classes
    print("\n3. Nested Classes:");
    mut uni = University("Tech University");
    mut student = University.Student("S001", "Alice", "Computer Science", 2);
    mut prof = University.Professor("P001", "Dr. Smith", "Computer Science");
    mut course = University.Course("CS101", "Introduction to Programming", 3);
    
    uni.add_student(student);
    uni.add_professor(prof);
    prof.teach_course(course);
    course.assign_professor(prof);
    
    print(uni.get_info());
    print(student.get_info());
    print(prof.get_info());
    print(course.get_info());
    
    # Test generic classes
    print("\n4. Generic Classes:");
    mut stack = Stack<number>();
    stack.push(1);
    stack.push(2);
    stack.push(3);
    print("Stack: ", stack.to_array());
    print("Stack pop: ", stack.pop());
    print("Stack peek: ", stack.peek());
    
    mut queue = Queue<string>();
    queue.enqueue("Hello");
    queue.enqueue("World");
    print("Queue: ", queue.to_array());
    print("Queue dequeue: ", queue.dequeue());
    print("Queue front: ", queue.front());
    
    # Test static methods
    print("\n5. Static Methods:");
    print("Factorial of 5: ", MathUtils.factorial(5));
    print("Fibonacci of 10: ", MathUtils.fibonacci(10));
    print("GCD of 12 and 18: ", MathUtils.gcd(12, 18));
    print("Is 17 prime: ", MathUtils.is_prime(17));
    
    print("Reverse 'hello': ", StringUtils.reverse("hello"));
    print("Capitalize 'world': ", StringUtils.capitalize("world"));
    print("Camel case 'hello world': ", StringUtils.camel_case("hello world"));
    print("Snake case 'HelloWorld': ", StringUtils.snake_case("HelloWorld"));
    
    # Test singleton
    print("\n6. Singleton:");
    mut s1 = Singleton.get_instance();
    mut s2 = Singleton.get_instance();
    print("Same instance: ", s1 == s2);
    print(s1.do_something());
    
    # Test factory
    print("\n7. Factory:");
    mut animal = Factory.create_animal("dog", "Max", 4);
    print(animal.get_info());
    print(animal.speak());
    
    print("\n=== OOP Demo completed! ===");
}

# Run the OOP demo
oop_demo();
