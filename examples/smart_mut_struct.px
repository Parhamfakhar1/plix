// Smart Mutability™ Example 5: Mutation of Object Fields with Aliasing Safety
// This example demonstrates how Smart Mutability™ works with object fields and aliasing

// Example 1: Basic object field mutation
person = {
    "name": "Alice",
    "age": 30,
    "city": "New York"
}

print("Original person: ${person}")

// Safe mutation of individual fields
person = {
    "name": person["name"],
    "age": person["age"] + 1,
    "city": "San Francisco"
}

print("Updated person: ${person}")

// Example 2: Object aliasing and safe mutation
data = {
    "items": [1, 2, 3],
    "count": 3
}

// Create an alias
reference = data

// Safe to read from alias
print("Items from reference: ${reference["items"]}")

// Safe mutation - only one mutable reference exists
data = {
    "items": [10, 20, 30],
    "count": 3
}

print("Updated data: ${data}")
print("Reference after update: ${reference}")

// Example 3: Nested object mutation
config = {
    "database": {
        "host": "localhost",
        "port": 5432
    },
    "debug": true
}

// Safe mutation of nested object
config = {
    "database": {
        "host": "prod-server",
        "port": 5432
    },
    "debug": false
}

print("Updated config: ${config}")

// Example 4: Function parameter with object
def update_user_info(user):
    // Create a new object with updated field
    return {
        "name": user["name"],
        "age": user["age"] + 1,
        "email": user["email"]
    }

user = {
    "name": "Bob",
    "age": 25,
    "email": "bob@example.com"
}

updated_user = update_user_info(user)

print("Original user: ${user}")      // Should remain unchanged
print("Updated user: ${updated_user}")  // Should have age incremented

// Example 5: Array of objects
inventory = [
    {"name": "apple", "quantity": 5},
    {"name": "banana", "quantity": 3}
]

// Safe mutation of array elements
updated_inventory = []
for item in inventory:
    if item["name"] == "apple":
        updated_item = {
            "name": item["name"],
            "quantity": item["quantity"] + 5
        }
    else:
        updated_item = item
    updated_inventory = updated_inventory + [updated_item]

inventory = updated_inventory
print("Updated inventory: ${inventory}")

// Example 6: Object method simulation
def create_counter(initial_value):
    return {
        "value": initial_value,
        "increment": "function",
        "get_value": "function"
    }

def increment_counter(counter):
    return {
        "value": counter["value"] + 1,
        "increment": "function",
        "get_value": "function"
    }

def get_counter_value(counter):
    return counter["value"]

counter = create_counter(0)
print("Initial counter value: ${get_counter_value(counter)}")

counter = increment_counter(counter)
print("After increment: ${get_counter_value(counter)}")

counter = increment_counter(counter)
print("After second increment: ${get_counter_value(counter)}")

// Expected behavior: All operations should compile successfully
// The compiler should track object field mutations and ensure aliasing safety
// Object fields can be safely mutated as long as there are no conflicting aliases
