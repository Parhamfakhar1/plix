// Smart Mutability™ Example 3: Unsafe Mutation (Should Fail to Compile)
// This example demonstrates mutation conflicts that should be caught at compile time

// Example 1: Multiple mutable references to the same value
data = [1, 2, 3]
ref1 = data  // First mutable reference
ref2 = data  // Second mutable reference - this should cause a compile error

// Attempting to mutate through ref1 should fail
ref1 = [10, 20, 30]  // Error: Cannot mutate `ref1` — already borrowed immutably at line 12

// Example 2: Mutation while value is borrowed
items = ["a", "b", "c"]
borrowed = items  // Immutable borrow

// This should fail - trying to mutate while borrowed
items = ["x", "y", "z"]  // Error: Cannot mutate `items` — already borrowed immutably at line 19

// Example 3: Function parameter conflicts
def update_list(list_param):
    list_param = [99, 88, 77]  // Trying to mutate parameter
    return list_param

my_list = [1, 2, 3]
result = update_list(my_list)  // This should cause a conflict

// Example 4: Nested scope conflicts
container = {"key": "value"}

if true:
    alias = container  // Borrow in nested scope
    container = {"new": "data"}  // Error: Cannot mutate while borrowed in nested scope

// Expected behavior: This file should fail to compile with clear error messages
// Each error should indicate the line where the conflict occurs and reference
// the line where the value was previously borrowed
